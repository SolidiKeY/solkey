\sorts {
    Memory;
    java.lang.Identity \extends java.lang.Object;
    IdentityPrim;
    Field;

	\generic alpha \extends any;

	Struct \extends any;
}


\functions{
    // Core
    Seq tail(Seq);
    alpha alpha::head(Seq);
    alpha alpha::last(Seq);

    // Memory
    \unique Memory mtMem;

    Memory write(Memory, Identity, Field, any);
    Memory addM(Memory, IdentityPrim);
    alpha alpha::read(Memory, Identity, Field);
    alpha alpha::readR(Memory, Identity, Seq);

    Identity idC(IdentityPrim, Seq);
    any default(Identity, Field);
    any defaultF(Field);

    // Storage
    \unique Struct mtSt;

    Struct storeSt(Struct, Field, any);
    Struct save(Struct, Seq, any);
    alpha alpha::selectSt(Struct, Field);
    alpha alpha::find(Struct, Seq);

    \unique Field size;

    // Memory to Storage
    Struct copyMem(Struct, Memory, Identity);

    // Storage to Memory
    Memory copySt(Memory, IdentityPrim, any);
}

\predicates {
    new(Memory, IdentityPrim);
    isPrimitive(Field);
}

\schemaVariables{
    \term Memory mem;
    \term Identity id, id1, id2;
    \term IdentityPrim idp1, idp2;
    \term Field fld, fld1, fld2;
    \term Seq flds, fxs;
    \term any v, v0, v1;
    \term Memory mem;
    \term Struct st;
}

\programVariables {
}

\rules {
    // Core
    headDefinition {
        \find(alpha::head(flds))
        \replacewith(alpha::seqGet(flds, 0))
        \heuristics(simplify_enlarging)
    };

    lastDefinition {
        \find(alpha::last(flds))
        \replacewith(alpha::seqGet(flds, seqLen(flds)-1))
        \heuristics(simplify_enlarging)
    };

    tailDefinition {
        \find(tail(flds))
        \replacewith(seqSub(flds, 1, seqLen(flds)))
        \heuristics(simplify_enlarging)
    };

    // Memory
    readOnWrite {
        \find(alpha::read(write(mem, id1, fld1, v), id2, fld2))
        \replacewith( \if ( id1 = id2 & fld1 = fld2)
                      \then (v)
                      \else (alpha::read(mem, id2, fld2))
                    )
        \heuristics(simplify_enlarging)
    };

    readOnaddM {
        \find(alpha::read(addM(mem, idp1), idC(idp2, flds), fld))
            \replacewith(
                \if (idp1 = idp2) \then (
                        default(idC(idp2, flds), fld)
                ) \else (
                        alpha::read(mem, idC(idp2, flds), fld)
                )
        )
        \heuristics(simplify_enlarging)
    };

    readFromEmptyMemory {
        \find(alpha::read(mtMem, id, fld))
        \replacewith(default(id, fld))
        \heuristics(simplify)
    };

    readRDefinition {
        \find(alpha::readR(mem, id, flds))
        \replacewith(
            \if( seqLen(flds) <= 1 )
            \then ( alpha::read(mem, id, Field::seqGet(flds, 0)) )
            \else ( alpha::read(mem, Identity::readR(mem, id, seqSub(flds, 0, seqLen(flds)-1)), Field::seqGet(flds, seqLen(flds)-1)) )
        )
        \heuristics(simplify)
    };

    newFromAdd {
        \find(new(addM(mem, idp1), idp2))
        \replacewith(
            \if (idp1 = idp2)
            \then (false)
            \else (new(mem, idp2))
        )
        \heuristics(simplify_enlarging)
    };

    newFromWrite {
        \find(new(write(mem, id1, fld1, v), idp2))
        \replacewith(new(mem, idp2))
        \heuristics(simplify_enlarging)
    };

    newFromEmptyMemory {
        \find(new(mtMem, idp1))
        \replacewith(true)
        \heuristics(simplify_enlarging)
    };

    // Storage
    selectOnStore {
        \find(alpha::selectSt(storeSt(st, fld1, v), fld2))
        \replacewith(
            \if (fld1 = fld2)
            \then (v)
            \else (alpha::selectSt(st,fld2))
        )
        \heuristics(simplify_enlarging)
    };

    selectOnEmptyStorage {
        \find(alpha::selectSt(mtSt, fld))
        \replacewith(alpha::defaultF(fld) )
        \heuristics(simplify_enlarging)
    };

    saveOnEmptyStorage {
        \find(save(mtSt, flds, v))
        \replacewith(
            \if ( seqLen(flds) <= 0 )
            \then ( v )
            \else ( storeSt(mtSt, Field::head(flds), save(mtSt, tail(flds), v)) )
        )
        \heuristics(simplify_enlarging)
    };

    saveOnStore {
        \find(save(storeSt(st, fld, v0), flds, v1))
        \replacewith(
            \if ( seqLen(flds) <= 0 )
            \then ( v1 )
            \else (
                \if (fld = Field::head(flds))
                \then ( storeSt(st, fld,
                    \if ( seqLen(flds) <= 1 )
                    \then ( v1 )
                    \else ( save( (Struct)v0, tail(flds), v1) )
                ))
                \else ( storeSt(save(st, flds, v1), fld, v0) )
            )
        )
        \heuristics(simplify_enlarging)
    };

    findDefinition {
        \find(alpha::find(st, flds))
        \replacewith(
            \if ( seqLen(flds) <= 0 )
            \then ( (alpha) st )
            \else (
                \if(seqLen(flds) <= 1)
                \then( alpha::selectSt(st, Field::head(flds)) )
                \else( alpha::find(Struct::selectSt(st, Field::head(flds)), tail(flds)) )
            )
        )
        \heuristics(simplify_enlarging)
    };

    // lazy

    saveOnEmpty {
        \find(save(st, seqEmpty, v))
        \replacewith(v)
        \heuristics(simplify_enlarging)
    };

    selectOnSave {
        \find(alpha::selectSt(save(st,flds,v), fld))
        \replacewith(
            \if ( seqLen(flds) <= 0 )
            \then ( alpha::selectSt(save(st,flds,v), fld) )
            \else (
                \if( Field::head(flds) = fld )
                \then( (alpha) save(Struct::selectSt(st,fld), tail(flds), v) )
                \else( alpha::selectSt(st, fld) )
            )
        )
    };

    // Memory To Storage

    findOnCopy {
        \find(alpha::find(copyMem(st, mem, id), flds))
        \replacewith(
            \if (seqLen(flds) >= 1 & isPrimitive(Field::last(flds)))
            \then (alpha::readR(mem, id, flds))
            \else (alpha::find(copyMem(st, mem, id), flds))
        )
    };

    // Storage to Memory

    readFromCopyToStorage {
        \find( alpha::read(copySt(mem, idp1, st), idC(idp2, fxs), fld) )
        \replacewith (
            \if (idp1 = idp2)
            \then (
                \if ( isPrimitive(fld) )
                \then ( alpha::find(st, seqConcat(fxs, seqSingleton(fld))) )
                \else ( idC(idp1, seqConcat(fxs, seqSingleton(fld))) )
            )
            \else ( alpha::read(mem, idC(idp2, fxs), fld) )
        )
        \heuristics(simplify_enlarging)
    };
}